- [리팩토링 리스트](#리팩토링-리스트)
- [기본과제 진행과정](#기본과제-진행과정)
- [우리의 진행과정](#우리의-진행과정)
- [심화과제](#심화과제)
  - [1. 네이밍 규칙](#1-네이밍-규칙)
  - [2. 주석](#2-주석)
  - [3. 변수 및 상수](#3-변수-및-상수)
  - [4. 함수 작성 규칙](#4-함수-작성-규칙)
  - [5. 조건문](#5-조건문)
  - [6. 반복문](#6-반복문)
  - [7. 코드 구성](#7-코드-구성)
- [느낀점](#느낀점)
- [기본과제](#기본과제)
- [심화과제](#심화과제-1)

## 리팩토링 리스트

1. 기본과제

- [x] 코드가 Prettier를 통해 일관된 포맷팅이 적용되어 있는가?
- [x] 적절한 줄바꿈과 주석을 사용하여 코드의 논리적 단위를 명확히 구분했는가?
- [x] 변수명과 함수명이 그 역할을 명확히 나타내며, 일관된 네이밍 규칙을 따르는가?
- [x] 매직 넘버와 문자열을 의미 있는 상수로 추출했는가?
- [x] 중복 코드를 제거하고 재사용 가능한 형태로 리팩토링했는가?
- [x] 함수가 단일 책임 원칙을 따르며, 한 가지 작업만 수행하는가?
- [x] 조건문과 반복문이 간결하고 명확한가? 복잡한 조건을 함수로 추출했는가?
- [x] 코드의 배치가 의존성과 실행 흐름에 따라 논리적으로 구성되어 있는가?
- [x] 연관된 코드를 의미 있는 함수나 모듈로 그룹화했는가?
- [x] ES6+ 문법을 활용하여 코드를 더 간결하고 명확하게 작성했는가?
- [x] 전역 상태와 부수 효과(side effects)를 최소화했는가?
- [x] 에러 처리와 예외 상황을 명확히 고려하고 처리했는가?
- [x] 코드 자체가 자기 문서화되어 있어, 주석 없이도 의도를 파악할 수 있는가?
- [x] 비즈니스 로직과 UI 로직이 적절히 분리되어 있는가?
- [x] 객체지향 또는 함수형 프로그래밍 원칙을 적절히 적용했는가?
- [x] 코드의 각 부분이 테스트 가능하도록 구조화되어 있는가?
- [x] 성능 개선을 위해 불필요한 연산이나 렌더링을 제거했는가?
- [x] 새로운 기능 추가나 변경이 기존 코드에 미치는 영향을 최소화했는가?
- [x] 리팩토링 시 기존 기능을 그대로 유지하면서 점진적으로 개선했는가?
- [ ] 코드 리뷰를 통해 다른 개발자들의 피드백을 반영하고 개선했는가?

1. 심화과제

- [x] 코드가 Prettier를 통해 일관된 포맷팅이 적용되어 있는가?
- [x] 적절한 줄바꿈과 주석을 사용하여 코드의 논리적 단위를 명확히 구분했는가?
- [x] 변수명과 함수명이 그 역할을 명확히 나타내며, 일관된 네이밍 규칙을 따르는가?
- [x] 매직 넘버와 문자열을 의미 있는 상수로 추출했는가?
- [x] 중복 코드를 제거하고 재사용 가능한 형태로 리팩토링했는가?
- [x] 함수가 단일 책임 원칙을 따르며, 한 가지 작업만 수행하는가?
- [x] 조건문과 반복문이 간결하고 명확한가? 복잡한 조건을 함수로 추출했는가?
- [x] 코드의 배치가 의존성과 실행 흐름에 따라 논리적으로 구성되어 있는가?
- [x] 연관된 코드를 의미 있는 함수나 모듈로 그룹화했는가?
- [x] ES6+ 문법을 활용하여 코드를 더 간결하고 명확하게 작성했는가?
- [x] 전역 상태와 부수 효과(side effects)를 최소화했는가?
- [x] 에러 처리와 예외 상황을 명확히 고려하고 처리했는가?
- [x] 코드 자체가 자기 문서화되어 있어, 주석 없이도 의도를 파악할 수 있는가?
- [x] 비즈니스 로직과 UI 로직이 적절히 분리되어 있는가?
- [x] 객체지향 또는 함수형 프로그래밍 원칙을 적절히 적용했는가?
- [x] 코드의 각 부분이 테스트 가능하도록 구조화되어 있는가?
- [x] 성능 개선을 위해 불필요한 연산이나 렌더링을 제거했는가?
- [x] 새로운 기능 추가나 변경이 기존 코드에 미치는 영향을 최소화했는가?
- [x] 리팩토링 시 기존 기능을 그대로 유지하면서 점진적으로 개선했는가?
- [ ] 코드 리뷰를 통해 다른 개발자들의 피드백을 반영하고 개선했는가?

## 기본과제 진행과정

1. 변수 var -> let or const로 변경
2. document.createElement 대신 createElement 커스텀 함수 사용
   - html 프로퍼티 한번에 적용하도록 함
3. 문자열 ``(백틱)으로 변경
4. 함수
   1. 콜백 익명함수 전부 화살표 함수로 변경
   2. UI 업데이트 함수와 Data 업데이트 함수 분리
5. 고정되서 사용하는 숫자나 문자는 상수로 뺀다
   - const ALL_DISCOUNT_COUNT = 30;
6. 변수명
   1. sel -> select 축약형을 사용하지 않는다
   2. prodList -> products 복수형은 s를 붙인다.
   3. cartDisp -> UI관련 앞에는 ElCartContainer 앞에 El을 붙인다.
   4. sel -> ElProductSelect 어떤 것인지 최대한 자세하게 쓴다.
   5. 마지막을 나타내는 것은 과거형으로 쓴다 ex) selected
   6. 현재 값에 대해서는 current를 붙인다. ex) currentCount
   7. 현재 프로젝트에서는 상품의 금액이란 표현에 더 적합한 price로
   8. 수량을 나타내는 것은 q가 아닌 다양하게 사용할 수 있는 count로 한다.
   9. 유추 할 수 있는 객체는 분해할당한다. ex)products.find(({ id }) => id === targetProductItemId)
7. 함수명
   1. 이벤트 함수는 on + event + event target ex) onClickProductAddButton
   2. 일반 함수는 함수명에서 어떤 동작을 하는지 알아보게 한다.
      - calculatePoint -> 누가봐도 point계산 하는 함수
      - 동사 + 명사로

## 우리의 진행과정

- 팀원별 리팩토링 방식

  - 태영
    - 전체적인 것 보다, 디테일한 부분을 챙겨서 리팩토링을 함 ( 함수명, 변수명 어떻게 하는지 작은 단위에 집중 )
  - 수빈A
    - 전체적인 틀을 잘 짜서 리팩토링을 함 가장 정석적인 클린코드를 적용함
  - 아람
    - 중요하게 생각하는 부분에 따라 순차 적으로 리팩토링 진행 ( 함수명, 변수명, 역할에 따른 함수 분리 )
  - 단우
    - 너무 많은 부분을 제한 하면, 코드의 자유도가 너무 떨어짐 -> 중요한 부분을 정해서 리팩토링 진행함
  - 영우
    - 클린코드에서 말하는 애로우 펑션, 매직넘버 이런 것들이 정확히 어디에 쓰이는지 공부하며 리팩토링

- 팀원별 리팩토링 꼭 원하는 것
  - 태영
    - 복수형, 단수형, 수량, 가격, 사람, 이런 변수명은 확실히 통일했으면 좋겠다.
    - 함수명은 -> 동사 + 명사, 이벤트 핸들러는 on+event+eventTarget 하면 좋겠다!
  - 수빈 A
    - 해당 파일, 함수에 상단에 어떤 역할을 하는 친구들인지 주석으로 간략하게 남기기
  - 아람
    - var 사용 X let, const 목적에 맞게 정확하게 쓰기
    - 기능에 맞게 엔터 쳐서 그룹핑 하기
    - 이벤트 함수는 -> handle+동사 handleAddProduct
    - 일반 함수 -> 동사 + 명사 addProduct
    - 너무 심한 축약형 사용하지 않기
    - if(isBoolean === true) if문에 들어가는 부분은 무조건 boolean값인데 저렇게 사용하지 않기
  - 단우
    - 의미가 명확한 변수명을 사용하면 좋겠다. 합성어 2~3개 정도
    - if문의 조건이 true falsy 값을 너무 긴 연산으로 적지 않기, 너무 길어지면 변수로 빼기
  - 영우
    - 재사용 가능한 것들은 따로 빼놓자!
  - 진현
    - 함수명을 일관되게 작성 -> 할인이라고 하면 discount, sale 있으면 둘중 하나로 통일
    - 반복문은 for은 최대한 지양하고, HOC(고차함수)를 사용하자!
    - 변하지 않는 값은 상수로 처리
    - 함수는 단 하나의 기능만 정의한다.
- 의견 통일이 필요한 것

  - event 핸들러를 어떻게 할것인가!
    1. on + event + target -> onClickProdcutAddButton
       - 태영 : react에서 조차 event 핸들러를 추가하려면 on+event를 사용한다.
         그렇기에 훨씬 직관적이다!
       - 영우 : 직관적이어서 더 좋다
    2. handle + 동사
       - 아람 : on 방식 좋은데, 너무 길어지는 경우가 종종 있다.
    3. handle과 on을 상황에 따라 쓴다!
       - 단우 : 가벼운 이벤트는 on에서 처리, 무거운 이벤트는 handle 사용
       - 진현 : 단우님 말에 설득 되었다. 좋다!
       - 수빈 : 단우님에게 설득 되었다.
  - 결론 우리 과제에서는?
    - handle - 아람, 단우, 수빈, 영우, 진현 당첨!
    - on - 태영

## 심화과제

### 1. 네이밍 규칙

- **복수형, 단수형, 수량, 가격, 사람**등 같은 의미를 가진 단어는 하나로 통일하여 사용합니다.
  - 이번 과제에서
    - 가격 -> price
    - 수량 -> quantity
    - 총 가격 -> totalAmount (수량 X 가격 = amount라고 대부분 함)
- **축약형은 사용하지 않는다** cnt -> count 전부 노 축약
- **함수명**: `동사 + 명사` 형식으로 작성합니다. (예: `addProduct`)
- **이벤트 핸들러**: `handle + 동사 + 타겟` 형식으로 작성합니다. (예: `handleAddProductButton`)
  - 타겟까지 붙여주기

### 2. 주석

- 각 파일 또는 함수 상단에 해당 파일/함수의 역할을 간략히 설명하는 주석을 추가합니다. jsDoc 권장 ^^ - 수빈A

### 3. 변수 및 상수

- `var`를 사용하지 않습니다. 대신, `let`과 `const`를 목적에 맞게 정확하게 사용합니다.
- **변수명**은 의미가 명확하고, 2~3개의 단어로 구성된 이름을 사용합니다.
- 변하지 않는 값은 **상수**로 정의합니다.

### 4. 함수 작성 규칙

- **이벤트 함수**: `handle + 동사 + 타겟` 형식으로 작성합니다. (예: `handleAddProductButton`)
- **일반 함수**: `동사 + 명사 ` 형식으로 작성합니다. (예: `addProduct`)
- 함수는 **단일 책임 원칙**을 따르며, 하나의 기능만 수행합니다.

### 5. 조건문

- `if(isBoolean === true)`와 같은 불필요한 조건문을 지양하고, `boolean` 값만 바로 사용합니다.
- `if`문의 조건이 너무 길어지면, 조건을 변수로 분리하여 사용합니다.
- `if`에 축약 없이 `{}`를 항상 붙여준다

### 6. 반복문

- `for`문은 가급적 지양하고, 대신 **고차 함수(Higher-Order Functions)** 를 사용합니다.

### 7. 코드 구성

- 관련된 기능끼리는 **엔터**로 구분하여 그룹화합니다.
- 재사용 가능한 코드는 **별도의 파일**로 분리하여 관리합니다.

## 느낀점

## 기본과제

- 구현 기록

1. 함수들이 여러개 선언되어있고 함수들이 실행되는 형태. 전역변수로 선언된 것들도 있음.
2. 함수 분리 -> 함수 명 -> 변수명 -> 그룹핑 순으로 진행할 예정.
3. 함수 main 안에 여러 기능을 가진 로직(createElement, element의 attribute를 정해주는 로직 등)들이 섞여 있었고 기능에 맞게 함수들을 분리해주는 것이 좋겠다.
4. 먼저 main함수를 분리해보기로 결정. main 함수안에는 prodList와 root, cont 등 element들을 생성하고 attribute들을 설정하는 로직, 부모요소에 자식 요소들을 붙여주는 로직, setTimeout이 2개가 있음.
5. 먼저 createElement하는 로직 분리. -> 함수명은 createElement로 지음(이 함수의 역할은 element들을 새로 만들어 내는 것이기 때문).
6. 전역변수가 아닌 root, cont, wrap, hTxt는 return해 줌. 지역변수이기 때문에 var를 쓸 필요가 없고 그 안에서 재할당 해주는 곳이 없기 때문에 const로 변경함.
7. 속성들을 정하는 함수의 이름은 setElementAttribute로 지음. 직관적으로 정하다 + element + 속성을 합침.
8. 그 다음에는 appendChild를 통해 DOM을 만드는 기능을 가진 함수로 addElement라는 이름으로 만들었다(더하다 + element)
9. setTimeout 안에 있는 callback을 따로 분리하여 선언해주기로 했다(setTimeout안에 callback이 복잡하게 되어있어 가독성이 떨어짐)
10. callback은 중복적으로 쓰이는 곳이 없어 main 함수 안에 작성. callback 함수의 이름은 handle + 번개세일(surprise sale). 구매 제안하는 callback 함수는 handle+suggest.
11. addEventListner들의 callback 함수들을 바깥에 선언해줘 가독성을 높임.
12. 추가하기 버튼을 누르면 callback함수의 실행되기 때문에 handle + add button, handle+cart item
13. 함수들을 분리하고 나니 실행순서가 눈에 보이기 시작했다. main 실행 후 요소들에 클릭 이벤트를 걸어 놓은걸로 크게 나눌 수 있고, main 함수 안에서 createElement, setElementAttribute, updateSelOpts, addElement, calcCart, setTimeout이 실행된다. 함수 선언부들을 위에 위치시키고 실행부는 밑으로 옮겼다.
14. 변수명들을 정리하기 전 전역변수들이 이렇게 많이 필요한지 살펴봄(전역 변수를 많이 선언할 경우 메모리를 많이 잡아 먹음. 지역변수일 경우 함수가 실행될 때만 선언됨).
15. 함수 안에서만 사용하는 변수들을 할당 이후 값이 바뀐다면 let, 아니면 const로 변경
16. 함수 내에서 비슷한 일을 하는 코드들끼리 그룹핑.
17. 화살표 함수로 만들 수 있는건 화살표 함수로 만들기
18. 변수들의 변수명 변경. 직관적이고 어떤 값인지 알 수 있도록 지향. 변수는 명사로 짓기.(cont -> container, hTxt -> cart(장바구니를 나타내기 때문), sum -> totalAmount) 변수명이 너무 길지 않다면(15글자 이하 -> 여기에 대한 근거는? 아직 없다) 축약형을 쓰지 말자(addBtn -> addButton, prodList -> productList). element 요소들에게는 이름뒤에 element를 붙여줌(다른 변수값들과 쉽게 구분하기 위해)
19. 수량은 quantity, 합산한 금액은 amount, 물건의 가격은 price로 이름지음.
20. createUI안에서 createElement, setElementAttribute, addElement의 중복들을 피하기 위해 하나의 함수로 변경.
21. if문 안에 early return을 할 수 있는 것들은 early return 할 수 있도록 수정.
22. UI를 업데이트하는 로직과 비지니스 로직 분리.

## 심화과제

- 구현과정

1. react, typescript와 관련된 패키지들을 설치(react, react-dom, @vite/react,@babel/plugin-transform-react-jsx, typescript)
2. tailwind.config.json을 만들고 config 설정, vite.config.js에 js에서 jsx도 읽을 수 있도록 플러그인 설정
3. main.advanced.js에 App(root component)를 연결시킴.
4. basic 과제에서 리팩토링한 코드를 보고 UI부터 구성하기 시작.
5. UI 구성 후 비지니스 로직도 하나씩 옮기기 시작.
6. 전역변수는 useState로 변환.
7. main에서 실행된 순서대로 App 컴포넌트에 옮겨 구현.
8. UI와 비지니스 로직 모두 옮김
9. UI들을 관심사에 따라 분리(id로 이미 나눠져 있어 편하게 분리함).
10. 하지만 비지니스 로직에 데이터들이 서로 연결되어있는것들이 많아 복잡해 보임 -> 비지니스 로직들을 커스텀훅으로 빼보기로 함.
11.
